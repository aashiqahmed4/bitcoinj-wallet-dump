// Code generated by protoc-gen-go.
// source: wallet.proto
// DO NOT EDIT!

/*
Package wallet is a generated protocol buffer package.

It is generated from these files:
	wallet.proto

It has these top-level messages:
	PeerAddress
	EncryptedData
	DeterministicKey
	Key
	Script
	TransactionInput
	TransactionOutput
	TransactionConfidence
	Transaction
	ScryptParameters
	Extension
	Tag
	TransactionSigner
	Wallet
	ExchangeRate
*/
package wallet

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Key_Type int32

const (
	// * Unencrypted - Original bitcoin secp256k1 curve
	Key_ORIGINAL Key_Type = 1
	// * Encrypted with Scrypt and AES - Original bitcoin secp256k1 curve
	Key_ENCRYPTED_SCRYPT_AES Key_Type = 2
	// *
	// Not really a key, but rather contains the mnemonic phrase for a deterministic key hierarchy in the private_key field.
	// The label and public_key fields are missing. Creation timestamp will exist.
	Key_DETERMINISTIC_MNEMONIC Key_Type = 3
	// *
	// A key that was derived deterministically. Note that the root seed that created it may NOT be present in the
	// wallet, for the case of watching wallets. A deterministic key may or may not have the private key bytes present.
	// However the public key bytes and the deterministic_key field are guaranteed to exist. In a wallet where there
	// is a path from this key up to a key that has (possibly encrypted) private bytes, it's expected that the private
	// key can be rederived on the fly.
	Key_DETERMINISTIC_KEY Key_Type = 4
)

var Key_Type_name = map[int32]string{
	1: "ORIGINAL",
	2: "ENCRYPTED_SCRYPT_AES",
	3: "DETERMINISTIC_MNEMONIC",
	4: "DETERMINISTIC_KEY",
}
var Key_Type_value = map[string]int32{
	"ORIGINAL":               1,
	"ENCRYPTED_SCRYPT_AES":   2,
	"DETERMINISTIC_MNEMONIC": 3,
	"DETERMINISTIC_KEY":      4,
}

func (x Key_Type) Enum() *Key_Type {
	p := new(Key_Type)
	*p = x
	return p
}
func (x Key_Type) String() string {
	return proto.EnumName(Key_Type_name, int32(x))
}
func (x *Key_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Key_Type_value, data, "Key_Type")
	if err != nil {
		return err
	}
	*x = Key_Type(value)
	return nil
}
func (Key_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type TransactionConfidence_Type int32

const (
	TransactionConfidence_UNKNOWN           TransactionConfidence_Type = 0
	TransactionConfidence_BUILDING          TransactionConfidence_Type = 1
	TransactionConfidence_PENDING           TransactionConfidence_Type = 2
	TransactionConfidence_NOT_IN_BEST_CHAIN TransactionConfidence_Type = 3
	TransactionConfidence_DEAD              TransactionConfidence_Type = 4
)

var TransactionConfidence_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "BUILDING",
	2: "PENDING",
	3: "NOT_IN_BEST_CHAIN",
	4: "DEAD",
}
var TransactionConfidence_Type_value = map[string]int32{
	"UNKNOWN":           0,
	"BUILDING":          1,
	"PENDING":           2,
	"NOT_IN_BEST_CHAIN": 3,
	"DEAD":              4,
}

func (x TransactionConfidence_Type) Enum() *TransactionConfidence_Type {
	p := new(TransactionConfidence_Type)
	*p = x
	return p
}
func (x TransactionConfidence_Type) String() string {
	return proto.EnumName(TransactionConfidence_Type_name, int32(x))
}
func (x *TransactionConfidence_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionConfidence_Type_value, data, "TransactionConfidence_Type")
	if err != nil {
		return err
	}
	*x = TransactionConfidence_Type(value)
	return nil
}
func (TransactionConfidence_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

// Where did we get this transaction from? Knowing the source may help us to risk analyze pending transactions.
type TransactionConfidence_Source int32

const (
	TransactionConfidence_SOURCE_UNKNOWN TransactionConfidence_Source = 0
	TransactionConfidence_SOURCE_NETWORK TransactionConfidence_Source = 1
	TransactionConfidence_SOURCE_SELF    TransactionConfidence_Source = 2
)

var TransactionConfidence_Source_name = map[int32]string{
	0: "SOURCE_UNKNOWN",
	1: "SOURCE_NETWORK",
	2: "SOURCE_SELF",
}
var TransactionConfidence_Source_value = map[string]int32{
	"SOURCE_UNKNOWN": 0,
	"SOURCE_NETWORK": 1,
	"SOURCE_SELF":    2,
}

func (x TransactionConfidence_Source) Enum() *TransactionConfidence_Source {
	p := new(TransactionConfidence_Source)
	*p = x
	return p
}
func (x TransactionConfidence_Source) String() string {
	return proto.EnumName(TransactionConfidence_Source_name, int32(x))
}
func (x *TransactionConfidence_Source) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TransactionConfidence_Source_value, data, "TransactionConfidence_Source")
	if err != nil {
		return err
	}
	*x = TransactionConfidence_Source(value)
	return nil
}
func (TransactionConfidence_Source) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 1}
}

// *
// This is a bitfield oriented enum, with the following bits:
//
// bit 0 - spent
// bit 1 - appears in alt chain
// bit 2 - appears in best chain
// bit 3 - double-spent
// bit 4 - pending (we would like the tx to go into the best chain)
//
// Not all combinations are interesting, just the ones actually used in the enum.
type Transaction_Pool int32

const (
	Transaction_UNSPENT          Transaction_Pool = 4
	Transaction_SPENT            Transaction_Pool = 5
	Transaction_INACTIVE         Transaction_Pool = 2
	Transaction_DEAD             Transaction_Pool = 10
	Transaction_PENDING          Transaction_Pool = 16
	Transaction_PENDING_INACTIVE Transaction_Pool = 18
)

var Transaction_Pool_name = map[int32]string{
	4:  "UNSPENT",
	5:  "SPENT",
	2:  "INACTIVE",
	10: "DEAD",
	16: "PENDING",
	18: "PENDING_INACTIVE",
}
var Transaction_Pool_value = map[string]int32{
	"UNSPENT":          4,
	"SPENT":            5,
	"INACTIVE":         2,
	"DEAD":             10,
	"PENDING":          16,
	"PENDING_INACTIVE": 18,
}

func (x Transaction_Pool) Enum() *Transaction_Pool {
	p := new(Transaction_Pool)
	*p = x
	return p
}
func (x Transaction_Pool) String() string {
	return proto.EnumName(Transaction_Pool_name, int32(x))
}
func (x *Transaction_Pool) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Transaction_Pool_value, data, "Transaction_Pool")
	if err != nil {
		return err
	}
	*x = Transaction_Pool(value)
	return nil
}
func (Transaction_Pool) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

// For what purpose the transaction was created.
type Transaction_Purpose int32

const (
	// Old wallets or the purpose genuinely is a mystery (e.g. imported from some external source).
	Transaction_UNKNOWN Transaction_Purpose = 0
	// Created in response to a user request for payment. This is the normal case.
	Transaction_USER_PAYMENT Transaction_Purpose = 1
	// Created automatically to move money from rotated keys.
	Transaction_KEY_ROTATION Transaction_Purpose = 2
	// Stuff used by Lighthouse.
	Transaction_ASSURANCE_CONTRACT_CLAIM  Transaction_Purpose = 3
	Transaction_ASSURANCE_CONTRACT_PLEDGE Transaction_Purpose = 4
	Transaction_ASSURANCE_CONTRACT_STUB   Transaction_Purpose = 5
	// Raise fee, e.g. child-pays-for-parent.
	Transaction_RAISE_FEE Transaction_Purpose = 6
)

var Transaction_Purpose_name = map[int32]string{
	0: "UNKNOWN",
	1: "USER_PAYMENT",
	2: "KEY_ROTATION",
	3: "ASSURANCE_CONTRACT_CLAIM",
	4: "ASSURANCE_CONTRACT_PLEDGE",
	5: "ASSURANCE_CONTRACT_STUB",
	6: "RAISE_FEE",
}
var Transaction_Purpose_value = map[string]int32{
	"UNKNOWN":                   0,
	"USER_PAYMENT":              1,
	"KEY_ROTATION":              2,
	"ASSURANCE_CONTRACT_CLAIM":  3,
	"ASSURANCE_CONTRACT_PLEDGE": 4,
	"ASSURANCE_CONTRACT_STUB":   5,
	"RAISE_FEE":                 6,
}

func (x Transaction_Purpose) Enum() *Transaction_Purpose {
	p := new(Transaction_Purpose)
	*p = x
	return p
}
func (x Transaction_Purpose) String() string {
	return proto.EnumName(Transaction_Purpose_name, int32(x))
}
func (x *Transaction_Purpose) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Transaction_Purpose_value, data, "Transaction_Purpose")
	if err != nil {
		return err
	}
	*x = Transaction_Purpose(value)
	return nil
}
func (Transaction_Purpose) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 1} }

// *
// The encryption type of the wallet.
//
// The encryption type is UNENCRYPTED for wallets where the wallet does not support encryption - wallets prior to
// encryption support are grandfathered in as this wallet type.
// When a wallet is ENCRYPTED_SCRYPT_AES the keys are either encrypted with the wallet password or are unencrypted.
type Wallet_EncryptionType int32

const (
	Wallet_UNENCRYPTED          Wallet_EncryptionType = 1
	Wallet_ENCRYPTED_SCRYPT_AES Wallet_EncryptionType = 2
)

var Wallet_EncryptionType_name = map[int32]string{
	1: "UNENCRYPTED",
	2: "ENCRYPTED_SCRYPT_AES",
}
var Wallet_EncryptionType_value = map[string]int32{
	"UNENCRYPTED":          1,
	"ENCRYPTED_SCRYPT_AES": 2,
}

func (x Wallet_EncryptionType) Enum() *Wallet_EncryptionType {
	p := new(Wallet_EncryptionType)
	*p = x
	return p
}
func (x Wallet_EncryptionType) String() string {
	return proto.EnumName(Wallet_EncryptionType_name, int32(x))
}
func (x *Wallet_EncryptionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Wallet_EncryptionType_value, data, "Wallet_EncryptionType")
	if err != nil {
		return err
	}
	*x = Wallet_EncryptionType(value)
	return nil
}
func (Wallet_EncryptionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{13, 0} }

type PeerAddress struct {
	IpAddress        []byte  `protobuf:"bytes,1,req,name=ip_address" json:"ip_address,omitempty"`
	Port             *uint32 `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	Services         *uint64 `protobuf:"varint,3,req,name=services" json:"services,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PeerAddress) Reset()                    { *m = PeerAddress{} }
func (m *PeerAddress) String() string            { return proto.CompactTextString(m) }
func (*PeerAddress) ProtoMessage()               {}
func (*PeerAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PeerAddress) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *PeerAddress) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *PeerAddress) GetServices() uint64 {
	if m != nil && m.Services != nil {
		return *m.Services
	}
	return 0
}

type EncryptedData struct {
	InitialisationVector []byte `protobuf:"bytes,1,req,name=initialisation_vector" json:"initialisation_vector,omitempty"`
	EncryptedPrivateKey  []byte `protobuf:"bytes,2,req,name=encrypted_private_key" json:"encrypted_private_key,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *EncryptedData) Reset()                    { *m = EncryptedData{} }
func (m *EncryptedData) String() string            { return proto.CompactTextString(m) }
func (*EncryptedData) ProtoMessage()               {}
func (*EncryptedData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EncryptedData) GetInitialisationVector() []byte {
	if m != nil {
		return m.InitialisationVector
	}
	return nil
}

func (m *EncryptedData) GetEncryptedPrivateKey() []byte {
	if m != nil {
		return m.EncryptedPrivateKey
	}
	return nil
}

// *
// Data attached to a Key message that defines the data needed by the BIP32 deterministic key hierarchy algorithm.
type DeterministicKey struct {
	// Random data that allows us to extend a key. Without this, we can't figure out the next key in the chain and
	// should just treat it as a regular ORIGINAL type key.
	ChainCode []byte `protobuf:"bytes,1,req,name=chain_code" json:"chain_code,omitempty"`
	// The path through the key tree. Each number is encoded in the standard form: high bit set for private derivation
	// and high bit unset for public derivation.
	Path []uint32 `protobuf:"varint,2,rep,name=path" json:"path,omitempty"`
	// How many children of this key have been issued, that is, given to the user when they requested a fresh key?
	// For the parents of keys being handed out, this is always less than the true number of children: the difference is
	// called the lookahead zone. These keys are put into Bloom filters so we can spot transactions made by clones of
	// this wallet - for instance when restoring from backup or if the seed was shared between devices.
	//
	// If this field is missing it means we're not issuing subkeys of this key to users.
	IssuedSubkeys *uint32 `protobuf:"varint,3,opt,name=issued_subkeys" json:"issued_subkeys,omitempty"`
	LookaheadSize *uint32 `protobuf:"varint,4,opt,name=lookahead_size" json:"lookahead_size,omitempty"`
	// *
	// Flag indicating that this key is a root of a following chain. This chain is following the next non-following chain.
	// Following/followed chains concept is used for married keychains, where the set of keys combined together to produce
	// a single P2SH multisignature address
	IsFollowing *bool `protobuf:"varint,5,opt,name=isFollowing" json:"isFollowing,omitempty"`
	// Number of signatures required to spend. This field is needed only for married keychains to reconstruct KeyChain
	// and represents the N value from N-of-M CHECKMULTISIG script. For regular single keychains it will always be 1.
	SigsRequiredToSpend *uint32 `protobuf:"varint,6,opt,name=sigsRequiredToSpend,def=1" json:"sigsRequiredToSpend,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *DeterministicKey) Reset()                    { *m = DeterministicKey{} }
func (m *DeterministicKey) String() string            { return proto.CompactTextString(m) }
func (*DeterministicKey) ProtoMessage()               {}
func (*DeterministicKey) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

const Default_DeterministicKey_SigsRequiredToSpend uint32 = 1

func (m *DeterministicKey) GetChainCode() []byte {
	if m != nil {
		return m.ChainCode
	}
	return nil
}

func (m *DeterministicKey) GetPath() []uint32 {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *DeterministicKey) GetIssuedSubkeys() uint32 {
	if m != nil && m.IssuedSubkeys != nil {
		return *m.IssuedSubkeys
	}
	return 0
}

func (m *DeterministicKey) GetLookaheadSize() uint32 {
	if m != nil && m.LookaheadSize != nil {
		return *m.LookaheadSize
	}
	return 0
}

func (m *DeterministicKey) GetIsFollowing() bool {
	if m != nil && m.IsFollowing != nil {
		return *m.IsFollowing
	}
	return false
}

func (m *DeterministicKey) GetSigsRequiredToSpend() uint32 {
	if m != nil && m.SigsRequiredToSpend != nil {
		return *m.SigsRequiredToSpend
	}
	return Default_DeterministicKey_SigsRequiredToSpend
}

// *
// A key used to control Bitcoin spending.
//
// Either the private key, the public key or both may be present.  It is recommended that
// if the private key is provided that the public key is provided too because deriving it is slow.
//
// If only the public key is provided, the key can only be used to watch the blockchain and verify
// transactions, and not for spending.
type Key struct {
	Type *Key_Type `protobuf:"varint,1,req,name=type,enum=wallet.Key_Type" json:"type,omitempty"`
	// Either the private EC key bytes (without any ASN.1 wrapping), or the deterministic root seed.
	// If the secret is encrypted, or this is a "watching entry" then this is missing.
	SecretBytes []byte `protobuf:"bytes,2,opt,name=secret_bytes" json:"secret_bytes,omitempty"`
	// If the secret data is encrypted, then secret_bytes is missing and this field is set.
	EncryptedData *EncryptedData `protobuf:"bytes,6,opt,name=encrypted_data" json:"encrypted_data,omitempty"`
	// The public EC key derived from the private key. We allow both to be stored to avoid mobile clients having to
	// do lots of slow EC math on startup. For DETERMINISTIC_MNEMONIC entries this is missing.
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key" json:"public_key,omitempty"`
	// User-provided label associated with the key.
	Label *string `protobuf:"bytes,4,opt,name=label" json:"label,omitempty"`
	// Timestamp stored as millis since epoch. Useful for skipping block bodies before this point. Only reason it's
	// optional is that some very old wallets don't have this data.
	CreationTimestamp *int64            `protobuf:"varint,5,opt,name=creation_timestamp" json:"creation_timestamp,omitempty"`
	DeterministicKey  *DeterministicKey `protobuf:"bytes,7,opt,name=deterministic_key" json:"deterministic_key,omitempty"`
	// The seed for a deterministic key hierarchy.  Derived from the mnemonic,
	// but cached here for quick startup.  Only applicable to a DETERMINISTIC_MNEMONIC key entry.
	DeterministicSeed []byte `protobuf:"bytes,8,opt,name=deterministic_seed" json:"deterministic_seed,omitempty"`
	// Encrypted version of the seed
	EncryptedDeterministicSeed *EncryptedData `protobuf:"bytes,9,opt,name=encrypted_deterministic_seed" json:"encrypted_deterministic_seed,omitempty"`
	XXX_unrecognized           []byte         `json:"-"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Key) GetType() Key_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Key_ORIGINAL
}

func (m *Key) GetSecretBytes() []byte {
	if m != nil {
		return m.SecretBytes
	}
	return nil
}

func (m *Key) GetEncryptedData() *EncryptedData {
	if m != nil {
		return m.EncryptedData
	}
	return nil
}

func (m *Key) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Key) GetLabel() string {
	if m != nil && m.Label != nil {
		return *m.Label
	}
	return ""
}

func (m *Key) GetCreationTimestamp() int64 {
	if m != nil && m.CreationTimestamp != nil {
		return *m.CreationTimestamp
	}
	return 0
}

func (m *Key) GetDeterministicKey() *DeterministicKey {
	if m != nil {
		return m.DeterministicKey
	}
	return nil
}

func (m *Key) GetDeterministicSeed() []byte {
	if m != nil {
		return m.DeterministicSeed
	}
	return nil
}

func (m *Key) GetEncryptedDeterministicSeed() *EncryptedData {
	if m != nil {
		return m.EncryptedDeterministicSeed
	}
	return nil
}

type Script struct {
	Program []byte `protobuf:"bytes,1,req,name=program" json:"program,omitempty"`
	// Timestamp stored as millis since epoch. Useful for skipping block bodies before this point
	// when watching for scripts on the blockchain.
	CreationTimestamp *int64 `protobuf:"varint,2,req,name=creation_timestamp" json:"creation_timestamp,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *Script) Reset()                    { *m = Script{} }
func (m *Script) String() string            { return proto.CompactTextString(m) }
func (*Script) ProtoMessage()               {}
func (*Script) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Script) GetProgram() []byte {
	if m != nil {
		return m.Program
	}
	return nil
}

func (m *Script) GetCreationTimestamp() int64 {
	if m != nil && m.CreationTimestamp != nil {
		return *m.CreationTimestamp
	}
	return 0
}

type TransactionInput struct {
	// Hash of the transaction this input is using.
	TransactionOutPointHash []byte `protobuf:"bytes,1,req,name=transaction_out_point_hash" json:"transaction_out_point_hash,omitempty"`
	// Index of transaction output used by this input.
	TransactionOutPointIndex *uint32 `protobuf:"varint,2,req,name=transaction_out_point_index" json:"transaction_out_point_index,omitempty"`
	// Script that contains the signatures/pubkeys.
	ScriptBytes []byte `protobuf:"bytes,3,req,name=script_bytes" json:"script_bytes,omitempty"`
	// Sequence number.
	Sequence *uint32 `protobuf:"varint,4,opt,name=sequence" json:"sequence,omitempty"`
	// Value of connected output, if known
	Value            *int64 `protobuf:"varint,5,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TransactionInput) Reset()                    { *m = TransactionInput{} }
func (m *TransactionInput) String() string            { return proto.CompactTextString(m) }
func (*TransactionInput) ProtoMessage()               {}
func (*TransactionInput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TransactionInput) GetTransactionOutPointHash() []byte {
	if m != nil {
		return m.TransactionOutPointHash
	}
	return nil
}

func (m *TransactionInput) GetTransactionOutPointIndex() uint32 {
	if m != nil && m.TransactionOutPointIndex != nil {
		return *m.TransactionOutPointIndex
	}
	return 0
}

func (m *TransactionInput) GetScriptBytes() []byte {
	if m != nil {
		return m.ScriptBytes
	}
	return nil
}

func (m *TransactionInput) GetSequence() uint32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *TransactionInput) GetValue() int64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type TransactionOutput struct {
	Value       *int64 `protobuf:"varint,1,req,name=value" json:"value,omitempty"`
	ScriptBytes []byte `protobuf:"bytes,2,req,name=script_bytes" json:"script_bytes,omitempty"`
	// If spent, the hash of the transaction doing the spend.
	SpentByTransactionHash []byte `protobuf:"bytes,3,opt,name=spent_by_transaction_hash" json:"spent_by_transaction_hash,omitempty"`
	// If spent, the index of the transaction input of the transaction doing the spend.
	SpentByTransactionIndex *int32 `protobuf:"varint,4,opt,name=spent_by_transaction_index" json:"spent_by_transaction_index,omitempty"`
	XXX_unrecognized        []byte `json:"-"`
}

func (m *TransactionOutput) Reset()                    { *m = TransactionOutput{} }
func (m *TransactionOutput) String() string            { return proto.CompactTextString(m) }
func (*TransactionOutput) ProtoMessage()               {}
func (*TransactionOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TransactionOutput) GetValue() int64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

func (m *TransactionOutput) GetScriptBytes() []byte {
	if m != nil {
		return m.ScriptBytes
	}
	return nil
}

func (m *TransactionOutput) GetSpentByTransactionHash() []byte {
	if m != nil {
		return m.SpentByTransactionHash
	}
	return nil
}

func (m *TransactionOutput) GetSpentByTransactionIndex() int32 {
	if m != nil && m.SpentByTransactionIndex != nil {
		return *m.SpentByTransactionIndex
	}
	return 0
}

// *
// A description of the confidence we have that a transaction cannot be reversed in the future.
//
// Parsing should be lenient, since this could change for different applications yet we should
// maintain backward compatibility.
type TransactionConfidence struct {
	// This is optional in case we add confidence types to prevent parse errors - backwards compatible.
	Type *TransactionConfidence_Type `protobuf:"varint,1,opt,name=type,enum=wallet.TransactionConfidence_Type" json:"type,omitempty"`
	// If type == BUILDING then this is the chain height at which the transaction was included.
	AppearedAtHeight *int32 `protobuf:"varint,2,opt,name=appeared_at_height" json:"appeared_at_height,omitempty"`
	// If set, hash of the transaction that double spent this one into oblivion. A transaction can be double spent by
	// multiple transactions in the case of several inputs being re-spent by several transactions but we don't
	// bother to track them all, just the first. This only makes sense if type = DEAD.
	OverridingTransaction []byte `protobuf:"bytes,3,opt,name=overriding_transaction" json:"overriding_transaction,omitempty"`
	// If type == BUILDING then this is the depth of the transaction in the blockchain.
	// Zero confirmations: depth = 0, one confirmation: depth = 1 etc.
	Depth            *int32                        `protobuf:"varint,4,opt,name=depth" json:"depth,omitempty"`
	BroadcastBy      []*PeerAddress                `protobuf:"bytes,6,rep,name=broadcast_by" json:"broadcast_by,omitempty"`
	Source           *TransactionConfidence_Source `protobuf:"varint,7,opt,name=source,enum=wallet.TransactionConfidence_Source" json:"source,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *TransactionConfidence) Reset()                    { *m = TransactionConfidence{} }
func (m *TransactionConfidence) String() string            { return proto.CompactTextString(m) }
func (*TransactionConfidence) ProtoMessage()               {}
func (*TransactionConfidence) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TransactionConfidence) GetType() TransactionConfidence_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return TransactionConfidence_UNKNOWN
}

func (m *TransactionConfidence) GetAppearedAtHeight() int32 {
	if m != nil && m.AppearedAtHeight != nil {
		return *m.AppearedAtHeight
	}
	return 0
}

func (m *TransactionConfidence) GetOverridingTransaction() []byte {
	if m != nil {
		return m.OverridingTransaction
	}
	return nil
}

func (m *TransactionConfidence) GetDepth() int32 {
	if m != nil && m.Depth != nil {
		return *m.Depth
	}
	return 0
}

func (m *TransactionConfidence) GetBroadcastBy() []*PeerAddress {
	if m != nil {
		return m.BroadcastBy
	}
	return nil
}

func (m *TransactionConfidence) GetSource() TransactionConfidence_Source {
	if m != nil && m.Source != nil {
		return *m.Source
	}
	return TransactionConfidence_SOURCE_UNKNOWN
}

type Transaction struct {
	// See Wallet.java for detailed description of pool semantics
	Version *int32 `protobuf:"varint,1,req,name=version" json:"version,omitempty"`
	Hash    []byte `protobuf:"bytes,2,req,name=hash" json:"hash,omitempty"`
	// If pool is not present, that means either:
	//  - This Transaction is either not in a wallet at all (the proto is re-used elsewhere)
	//  - Or it is stored but for other purposes, for example, because it is the overriding transaction of a double spend.
	//  - Or the Pool enum got a new value which your software is too old to parse.
	Pool              *Transaction_Pool    `protobuf:"varint,3,opt,name=pool,enum=wallet.Transaction_Pool" json:"pool,omitempty"`
	LockTime          *uint32              `protobuf:"varint,4,opt,name=lock_time" json:"lock_time,omitempty"`
	UpdatedAt         *int64               `protobuf:"varint,5,opt,name=updated_at" json:"updated_at,omitempty"`
	TransactionInput  []*TransactionInput  `protobuf:"bytes,6,rep,name=transaction_input" json:"transaction_input,omitempty"`
	TransactionOutput []*TransactionOutput `protobuf:"bytes,7,rep,name=transaction_output" json:"transaction_output,omitempty"`
	// A list of blocks in which the transaction has been observed (on any chain). Also, a number used to disambiguate
	// ordering within a block.
	BlockHash              [][]byte `protobuf:"bytes,8,rep,name=block_hash" json:"block_hash,omitempty"`
	BlockRelativityOffsets []int32  `protobuf:"varint,11,rep,name=block_relativity_offsets" json:"block_relativity_offsets,omitempty"`
	// Data describing where the transaction is in the chain.
	Confidence *TransactionConfidence `protobuf:"bytes,9,opt,name=confidence" json:"confidence,omitempty"`
	Purpose    *Transaction_Purpose   `protobuf:"varint,10,opt,name=purpose,enum=wallet.Transaction_Purpose,def=0" json:"purpose,omitempty"`
	// Exchange rate that was valid when the transaction was sent.
	ExchangeRate *ExchangeRate `protobuf:"bytes,12,opt,name=exchange_rate" json:"exchange_rate,omitempty"`
	// Memo of the transaction. It can be used to record the memo of the payment request that initiated the
	// transaction.
	Memo             *string `protobuf:"bytes,13,opt,name=memo" json:"memo,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Transaction) Reset()                    { *m = Transaction{} }
func (m *Transaction) String() string            { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()               {}
func (*Transaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

const Default_Transaction_Purpose Transaction_Purpose = Transaction_UNKNOWN

func (m *Transaction) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Transaction) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Transaction) GetPool() Transaction_Pool {
	if m != nil && m.Pool != nil {
		return *m.Pool
	}
	return Transaction_UNSPENT
}

func (m *Transaction) GetLockTime() uint32 {
	if m != nil && m.LockTime != nil {
		return *m.LockTime
	}
	return 0
}

func (m *Transaction) GetUpdatedAt() int64 {
	if m != nil && m.UpdatedAt != nil {
		return *m.UpdatedAt
	}
	return 0
}

func (m *Transaction) GetTransactionInput() []*TransactionInput {
	if m != nil {
		return m.TransactionInput
	}
	return nil
}

func (m *Transaction) GetTransactionOutput() []*TransactionOutput {
	if m != nil {
		return m.TransactionOutput
	}
	return nil
}

func (m *Transaction) GetBlockHash() [][]byte {
	if m != nil {
		return m.BlockHash
	}
	return nil
}

func (m *Transaction) GetBlockRelativityOffsets() []int32 {
	if m != nil {
		return m.BlockRelativityOffsets
	}
	return nil
}

func (m *Transaction) GetConfidence() *TransactionConfidence {
	if m != nil {
		return m.Confidence
	}
	return nil
}

func (m *Transaction) GetPurpose() Transaction_Purpose {
	if m != nil && m.Purpose != nil {
		return *m.Purpose
	}
	return Default_Transaction_Purpose
}

func (m *Transaction) GetExchangeRate() *ExchangeRate {
	if m != nil {
		return m.ExchangeRate
	}
	return nil
}

func (m *Transaction) GetMemo() string {
	if m != nil && m.Memo != nil {
		return *m.Memo
	}
	return ""
}

// * The parameters used in the scrypt key derivation function.
//  The default values are taken from http://www.tarsnap.com/scrypt/scrypt-slides.pdf.
//  They can be increased - n is the number of iterations performed and
//  r and p can be used to tweak the algorithm - see:
//  http://stackoverflow.com/questions/11126315/what-are-optimal-scrypt-work-factors
type ScryptParameters struct {
	Salt             []byte `protobuf:"bytes,1,req,name=salt" json:"salt,omitempty"`
	N                *int64 `protobuf:"varint,2,opt,name=n,def=16384" json:"n,omitempty"`
	R                *int32 `protobuf:"varint,3,opt,name=r,def=8" json:"r,omitempty"`
	P                *int32 `protobuf:"varint,4,opt,name=p,def=1" json:"p,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ScryptParameters) Reset()                    { *m = ScryptParameters{} }
func (m *ScryptParameters) String() string            { return proto.CompactTextString(m) }
func (*ScryptParameters) ProtoMessage()               {}
func (*ScryptParameters) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

const Default_ScryptParameters_N int64 = 16384
const Default_ScryptParameters_R int32 = 8
const Default_ScryptParameters_P int32 = 1

func (m *ScryptParameters) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *ScryptParameters) GetN() int64 {
	if m != nil && m.N != nil {
		return *m.N
	}
	return Default_ScryptParameters_N
}

func (m *ScryptParameters) GetR() int32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return Default_ScryptParameters_R
}

func (m *ScryptParameters) GetP() int32 {
	if m != nil && m.P != nil {
		return *m.P
	}
	return Default_ScryptParameters_P
}

// * An extension to the wallet
type Extension struct {
	Id   *string `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Data []byte  `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
	// If we do not understand a mandatory extension, abort to prevent data loss.
	// For example, this could be applied to a new type of holding, such as a contract, where
	// dropping of an extension in a read/write cycle could cause loss of value.
	Mandatory        *bool  `protobuf:"varint,3,req,name=mandatory" json:"mandatory,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Extension) Reset()                    { *m = Extension{} }
func (m *Extension) String() string            { return proto.CompactTextString(m) }
func (*Extension) ProtoMessage()               {}
func (*Extension) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Extension) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Extension) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Extension) GetMandatory() bool {
	if m != nil && m.Mandatory != nil {
		return *m.Mandatory
	}
	return false
}

// *
// A simple key->value mapping that has no interpreted content at all. A bit like the extensions mechanism except
// an extension is keyed by the ID of a piece of code that's loaded with the given data, and has the concept of
// being mandatory if that code isn't found. Whereas this is just a blind key/value store.
type Tag struct {
	Tag              *string `protobuf:"bytes,1,req,name=tag" json:"tag,omitempty"`
	Data             []byte  `protobuf:"bytes,2,req,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Tag) GetTag() string {
	if m != nil && m.Tag != nil {
		return *m.Tag
	}
	return ""
}

func (m *Tag) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// *
// Data required to reconstruct TransactionSigner.
type TransactionSigner struct {
	// fully qualified class name of TransactionSigner implementation
	ClassName *string `protobuf:"bytes,1,req,name=class_name" json:"class_name,omitempty"`
	// arbitrary data required for signer to function
	Data             []byte `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TransactionSigner) Reset()                    { *m = TransactionSigner{} }
func (m *TransactionSigner) String() string            { return proto.CompactTextString(m) }
func (*TransactionSigner) ProtoMessage()               {}
func (*TransactionSigner) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *TransactionSigner) GetClassName() string {
	if m != nil && m.ClassName != nil {
		return *m.ClassName
	}
	return ""
}

func (m *TransactionSigner) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// * A bitcoin wallet
type Wallet struct {
	NetworkIdentifier *string `protobuf:"bytes,1,req,name=network_identifier" json:"network_identifier,omitempty"`
	// The SHA256 hash of the head of the best chain seen by this wallet.
	LastSeenBlockHash []byte `protobuf:"bytes,2,opt,name=last_seen_block_hash" json:"last_seen_block_hash,omitempty"`
	// The height in the chain of the last seen block.
	LastSeenBlockHeight   *uint32                `protobuf:"varint,12,opt,name=last_seen_block_height" json:"last_seen_block_height,omitempty"`
	LastSeenBlockTimeSecs *int64                 `protobuf:"varint,14,opt,name=last_seen_block_time_secs" json:"last_seen_block_time_secs,omitempty"`
	Key                   []*Key                 `protobuf:"bytes,3,rep,name=key" json:"key,omitempty"`
	Transaction           []*Transaction         `protobuf:"bytes,4,rep,name=transaction" json:"transaction,omitempty"`
	WatchedScript         []*Script              `protobuf:"bytes,15,rep,name=watched_script" json:"watched_script,omitempty"`
	EncryptionType        *Wallet_EncryptionType `protobuf:"varint,5,opt,name=encryption_type,enum=wallet.Wallet_EncryptionType,def=1" json:"encryption_type,omitempty"`
	EncryptionParameters  *ScryptParameters      `protobuf:"bytes,6,opt,name=encryption_parameters" json:"encryption_parameters,omitempty"`
	// The version number of the wallet - used to detect wallets that were produced in the future
	// (i.e. the wallet may contain some future format this protobuf or parser code does not know about).
	// A version that's higher than the default is considered from the future.
	Version   *int32       `protobuf:"varint,7,opt,name=version,def=1" json:"version,omitempty"`
	Extension []*Extension `protobuf:"bytes,10,rep,name=extension" json:"extension,omitempty"`
	// A UTF8 encoded text description of the wallet that is intended for end user provided text.
	Description *string `protobuf:"bytes,11,opt,name=description" json:"description,omitempty"`
	// UNIX time in seconds since the epoch. If set, then any keys created before this date are assumed to be no longer
	// wanted. Money sent to them will be re-spent automatically to the first key that was created after this time. It
	// can be used to recover a compromised wallet, or just as part of preventative defence-in-depth measures.
	KeyRotationTime *uint64 `protobuf:"varint,13,opt,name=key_rotation_time" json:"key_rotation_time,omitempty"`
	Tags            []*Tag  `protobuf:"bytes,16,rep,name=tags" json:"tags,omitempty"`
	// transaction signers added to the wallet
	TransactionSigners []*TransactionSigner `protobuf:"bytes,17,rep,name=transaction_signers" json:"transaction_signers,omitempty"`
	XXX_unrecognized   []byte               `json:"-"`
}

func (m *Wallet) Reset()                    { *m = Wallet{} }
func (m *Wallet) String() string            { return proto.CompactTextString(m) }
func (*Wallet) ProtoMessage()               {}
func (*Wallet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

const Default_Wallet_EncryptionType Wallet_EncryptionType = Wallet_UNENCRYPTED
const Default_Wallet_Version int32 = 1

func (m *Wallet) GetNetworkIdentifier() string {
	if m != nil && m.NetworkIdentifier != nil {
		return *m.NetworkIdentifier
	}
	return ""
}

func (m *Wallet) GetLastSeenBlockHash() []byte {
	if m != nil {
		return m.LastSeenBlockHash
	}
	return nil
}

func (m *Wallet) GetLastSeenBlockHeight() uint32 {
	if m != nil && m.LastSeenBlockHeight != nil {
		return *m.LastSeenBlockHeight
	}
	return 0
}

func (m *Wallet) GetLastSeenBlockTimeSecs() int64 {
	if m != nil && m.LastSeenBlockTimeSecs != nil {
		return *m.LastSeenBlockTimeSecs
	}
	return 0
}

func (m *Wallet) GetKey() []*Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Wallet) GetTransaction() []*Transaction {
	if m != nil {
		return m.Transaction
	}
	return nil
}

func (m *Wallet) GetWatchedScript() []*Script {
	if m != nil {
		return m.WatchedScript
	}
	return nil
}

func (m *Wallet) GetEncryptionType() Wallet_EncryptionType {
	if m != nil && m.EncryptionType != nil {
		return *m.EncryptionType
	}
	return Default_Wallet_EncryptionType
}

func (m *Wallet) GetEncryptionParameters() *ScryptParameters {
	if m != nil {
		return m.EncryptionParameters
	}
	return nil
}

func (m *Wallet) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return Default_Wallet_Version
}

func (m *Wallet) GetExtension() []*Extension {
	if m != nil {
		return m.Extension
	}
	return nil
}

func (m *Wallet) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *Wallet) GetKeyRotationTime() uint64 {
	if m != nil && m.KeyRotationTime != nil {
		return *m.KeyRotationTime
	}
	return 0
}

func (m *Wallet) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Wallet) GetTransactionSigners() []*TransactionSigner {
	if m != nil {
		return m.TransactionSigners
	}
	return nil
}

// * An exchange rate between Bitcoin and some fiat currency.
type ExchangeRate struct {
	// This much of satoshis (1E-8 fractions)…
	CoinValue *int64 `protobuf:"varint,1,req,name=coin_value" json:"coin_value,omitempty"`
	// …is worth this much of fiat (1E-4 fractions).
	FiatValue *int64 `protobuf:"varint,2,req,name=fiat_value" json:"fiat_value,omitempty"`
	// ISO 4217 currency code (if available) of the fiat currency.
	FiatCurrencyCode *string `protobuf:"bytes,3,req,name=fiat_currency_code" json:"fiat_currency_code,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExchangeRate) Reset()                    { *m = ExchangeRate{} }
func (m *ExchangeRate) String() string            { return proto.CompactTextString(m) }
func (*ExchangeRate) ProtoMessage()               {}
func (*ExchangeRate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ExchangeRate) GetCoinValue() int64 {
	if m != nil && m.CoinValue != nil {
		return *m.CoinValue
	}
	return 0
}

func (m *ExchangeRate) GetFiatValue() int64 {
	if m != nil && m.FiatValue != nil {
		return *m.FiatValue
	}
	return 0
}

func (m *ExchangeRate) GetFiatCurrencyCode() string {
	if m != nil && m.FiatCurrencyCode != nil {
		return *m.FiatCurrencyCode
	}
	return ""
}

func init() {
	proto.RegisterType((*PeerAddress)(nil), "wallet.PeerAddress")
	proto.RegisterType((*EncryptedData)(nil), "wallet.EncryptedData")
	proto.RegisterType((*DeterministicKey)(nil), "wallet.DeterministicKey")
	proto.RegisterType((*Key)(nil), "wallet.Key")
	proto.RegisterType((*Script)(nil), "wallet.Script")
	proto.RegisterType((*TransactionInput)(nil), "wallet.TransactionInput")
	proto.RegisterType((*TransactionOutput)(nil), "wallet.TransactionOutput")
	proto.RegisterType((*TransactionConfidence)(nil), "wallet.TransactionConfidence")
	proto.RegisterType((*Transaction)(nil), "wallet.Transaction")
	proto.RegisterType((*ScryptParameters)(nil), "wallet.ScryptParameters")
	proto.RegisterType((*Extension)(nil), "wallet.Extension")
	proto.RegisterType((*Tag)(nil), "wallet.Tag")
	proto.RegisterType((*TransactionSigner)(nil), "wallet.TransactionSigner")
	proto.RegisterType((*Wallet)(nil), "wallet.Wallet")
	proto.RegisterType((*ExchangeRate)(nil), "wallet.ExchangeRate")
	proto.RegisterEnum("wallet.Key_Type", Key_Type_name, Key_Type_value)
	proto.RegisterEnum("wallet.TransactionConfidence_Type", TransactionConfidence_Type_name, TransactionConfidence_Type_value)
	proto.RegisterEnum("wallet.TransactionConfidence_Source", TransactionConfidence_Source_name, TransactionConfidence_Source_value)
	proto.RegisterEnum("wallet.Transaction_Pool", Transaction_Pool_name, Transaction_Pool_value)
	proto.RegisterEnum("wallet.Transaction_Purpose", Transaction_Purpose_name, Transaction_Purpose_value)
	proto.RegisterEnum("wallet.Wallet_EncryptionType", Wallet_EncryptionType_name, Wallet_EncryptionType_value)
}

var fileDescriptor0 = []byte{
	// 1557 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x57, 0x5f, 0x53, 0xdb, 0x48,
	0x12, 0x3f, 0x23, 0x1b, 0xec, 0xb6, 0x31, 0x42, 0x40, 0x4e, 0x24, 0x21, 0x95, 0xd3, 0xa5, 0x52,
	0xb9, 0xba, 0x3a, 0xea, 0xf2, 0xf7, 0x52, 0xe4, 0xc9, 0xd8, 0x4a, 0xce, 0x05, 0xc8, 0x2e, 0x4b,
	0x1c, 0xc5, 0x93, 0x6a, 0xb0, 0x06, 0x33, 0x87, 0x90, 0x14, 0xcd, 0x18, 0xe2, 0x7b, 0xb9, 0xe7,
	0x7d, 0xdd, 0xb7, 0xdd, 0xd7, 0xfd, 0x28, 0xfb, 0x69, 0xf6, 0x5b, 0x6c, 0xcf, 0x48, 0xb6, 0xe5,
	0xe0, 0xe5, 0xcd, 0xea, 0xee, 0xe9, 0xf9, 0x4d, 0xcf, 0xaf, 0x7f, 0xd3, 0x86, 0xc6, 0x1d, 0x09,
	0x43, 0x2a, 0xf6, 0x93, 0x34, 0x16, 0xb1, 0xb1, 0x9a, 0x7d, 0x59, 0x2d, 0xa8, 0xf7, 0x29, 0x4d,
	0x5b, 0x41, 0x90, 0x52, 0xce, 0x0d, 0x03, 0x80, 0x25, 0x3e, 0xc9, 0xbe, 0xcc, 0xd2, 0xf3, 0x95,
	0x57, 0x0d, 0xa3, 0x01, 0xe5, 0x24, 0x4e, 0x85, 0xb9, 0x82, 0x5f, 0xeb, 0x86, 0x0e, 0x55, 0x4e,
	0xd3, 0x5b, 0x36, 0xa4, 0xdc, 0xd4, 0xd0, 0x52, 0xb6, 0x4e, 0x60, 0xdd, 0x8e, 0x86, 0xe9, 0x24,
	0x11, 0x34, 0xe8, 0x10, 0x41, 0x8c, 0x3d, 0xd8, 0x61, 0x11, 0x13, 0x8c, 0x84, 0x8c, 0x13, 0xc1,
	0xe2, 0xc8, 0xbf, 0xa5, 0x43, 0x11, 0xa7, 0x79, 0x3e, 0x74, 0xd3, 0x69, 0xbc, 0x9f, 0xa4, 0xec,
	0x96, 0x08, 0xea, 0x5f, 0xd3, 0x89, 0xda, 0xa0, 0x61, 0xfd, 0x54, 0x02, 0xbd, 0x43, 0x05, 0x4d,
	0x6f, 0x30, 0x09, 0x17, 0x6c, 0x78, 0x44, 0x27, 0x12, 0xd7, 0xf0, 0x8a, 0xb0, 0xc8, 0x1f, 0xc6,
	0x01, 0x2d, 0xe0, 0x22, 0xe2, 0x0a, 0x97, 0x69, 0x88, 0xeb, 0x11, 0x34, 0x19, 0xe7, 0x63, 0x4c,
	0xc9, 0xc7, 0x17, 0x98, 0x4d, 0xa2, 0x2b, 0x65, 0xf6, 0x30, 0x8e, 0xaf, 0xc9, 0x15, 0x25, 0xe8,
	0x62, 0xff, 0xa3, 0x66, 0x59, 0xd9, 0xb7, 0xa0, 0xce, 0xf8, 0xe7, 0x38, 0x0c, 0xe3, 0x3b, 0x16,
	0x8d, 0xcc, 0x0a, 0x1a, 0xab, 0xc6, 0x33, 0xd8, 0xe2, 0x6c, 0xc4, 0x07, 0xf4, 0xeb, 0x98, 0xa5,
	0x34, 0xf0, 0x62, 0x37, 0xa1, 0x51, 0x60, 0xae, 0xca, 0x15, 0x07, 0xa5, 0xd7, 0xd6, 0xcf, 0x1a,
	0x68, 0x12, 0xce, 0x33, 0x28, 0x8b, 0x49, 0x92, 0x01, 0x69, 0xbe, 0xd1, 0xf7, 0xf3, 0xd2, 0xa2,
	0x6b, 0xdf, 0x43, 0xbb, 0xb1, 0x0d, 0x0d, 0x4e, 0x87, 0x29, 0x15, 0xfe, 0xc5, 0x44, 0x60, 0xa1,
	0x56, 0x30, 0x41, 0xc3, 0xf8, 0x07, 0x34, 0xe7, 0x07, 0x0f, 0xb0, 0x52, 0x2a, 0x71, 0xfd, 0xcd,
	0xce, 0x74, 0xfd, 0x62, 0x19, 0xf1, 0xcc, 0xc9, 0xf8, 0x22, 0x64, 0x43, 0x55, 0x1c, 0x4d, 0xa5,
	0x58, 0x87, 0x4a, 0x48, 0x2e, 0x68, 0xa8, 0x0e, 0x51, 0x33, 0x1e, 0x83, 0x81, 0xbb, 0x64, 0x35,
	0x16, 0xec, 0x86, 0x72, 0x41, 0x6e, 0x12, 0x75, 0x16, 0xcd, 0x78, 0x0b, 0x9b, 0x41, 0xb1, 0x8c,
	0x2a, 0xcb, 0x9a, 0xda, 0xd0, 0x9c, 0x6e, 0x78, 0xaf, 0xce, 0x98, 0x70, 0x71, 0x11, 0xa7, 0x34,
	0x30, 0xab, 0x6a, 0xef, 0x4f, 0xf0, 0xb4, 0x00, 0xff, 0x7e, 0x54, 0xed, 0x81, 0xc3, 0x58, 0x04,
	0xca, 0xaa, 0x32, 0x0d, 0xa8, 0xf6, 0x06, 0xdd, 0x2f, 0x5d, 0xa7, 0x75, 0xac, 0x97, 0x0c, 0x13,
	0xb6, 0x6d, 0xa7, 0x3d, 0x38, 0xef, 0x7b, 0x76, 0xc7, 0x77, 0xd5, 0x0f, 0xbf, 0x65, 0xbb, 0xfa,
	0x0a, 0x02, 0x79, 0xd4, 0xb1, 0x3d, 0x7b, 0x70, 0xd2, 0x75, 0xba, 0xae, 0xd7, 0x6d, 0xfb, 0x27,
	0x8e, 0x7d, 0xd2, 0x73, 0xba, 0x6d, 0x5d, 0x33, 0x76, 0x60, 0x73, 0xd1, 0x77, 0x64, 0x9f, 0xeb,
	0x65, 0xeb, 0x3d, 0xac, 0xba, 0xc3, 0x94, 0x25, 0xc2, 0xd8, 0x80, 0x35, 0x64, 0xf9, 0x28, 0x25,
	0x37, 0x39, 0x55, 0x96, 0xd7, 0x49, 0xf2, 0x4d, 0xb3, 0x7e, 0x44, 0xbe, 0x79, 0x29, 0x89, 0x38,
	0x19, 0x4a, 0x7f, 0x37, 0x4a, 0xc6, 0xc2, 0xb0, 0xe0, 0xb1, 0x98, 0xdb, 0xfc, 0x78, 0x2c, 0xfc,
	0x24, 0x66, 0x91, 0xf0, 0xaf, 0x08, 0xbf, 0xca, 0x93, 0xfe, 0x15, 0x9e, 0x2c, 0x8f, 0x61, 0x51,
	0x40, 0xbf, 0xe5, 0xed, 0x22, 0x99, 0xa0, 0x40, 0xe5, 0x4c, 0xd0, 0xd4, 0x52, 0xd5, 0x44, 0x5f,
	0xc7, 0x58, 0xce, 0x29, 0x1d, 0xf1, 0x62, 0x6f, 0x49, 0x38, 0xa6, 0xd9, 0xe5, 0x59, 0xff, 0x87,
	0xcd, 0x02, 0xa6, 0xde, 0x58, 0x48, 0x50, 0xb3, 0x18, 0xb9, 0xbf, 0x76, 0x2f, 0xb5, 0x6a, 0x1f,
	0xe3, 0x2f, 0xb0, 0xcb, 0x91, 0xb4, 0xd2, 0xe8, 0x17, 0xe1, 0x29, 0xe0, 0x19, 0x89, 0xf0, 0x70,
	0x4b, 0x43, 0x32, 0xdc, 0x12, 0x4f, 0xc5, 0xfa, 0x41, 0x83, 0x9d, 0x02, 0x82, 0x76, 0x1c, 0x5d,
	0xb2, 0x40, 0xe2, 0x35, 0xfe, 0x39, 0xe3, 0x7e, 0x09, 0xb9, 0x6f, 0x4d, 0xaf, 0x7b, 0x69, 0x70,
	0xd6, 0x0d, 0x58, 0x7d, 0x92, 0x24, 0x94, 0x60, 0x47, 0xf9, 0x04, 0x4b, 0x48, 0xd9, 0xe8, 0x4a,
	0xa8, 0x9e, 0xa8, 0x60, 0x27, 0x3d, 0x8a, 0x6f, 0x69, 0x9a, 0xb2, 0x00, 0xbb, 0xb0, 0x88, 0x66,
	0x4e, 0xf8, 0x80, 0x26, 0xd8, 0xe5, 0x0a, 0x96, 0xf1, 0x37, 0x68, 0x5c, 0xa4, 0x31, 0x09, 0x86,
	0x84, 0x4b, 0xf8, 0xd8, 0x40, 0x1a, 0x72, 0x6e, 0x6b, 0x0a, 0xa2, 0x28, 0x65, 0xef, 0x60, 0x95,
	0xc7, 0xe3, 0x14, 0x2b, 0xbc, 0xa6, 0x90, 0xbe, 0x78, 0x18, 0xa9, 0xab, 0x62, 0xad, 0x5e, 0xce,
	0xd3, 0x3a, 0xac, 0x9d, 0x3a, 0x47, 0x4e, 0xef, 0xcc, 0xd1, 0xff, 0x24, 0x49, 0x7b, 0x78, 0xda,
	0x3d, 0xee, 0x74, 0x9d, 0x2f, 0x48, 0x5a, 0x74, 0xf5, 0x6d, 0x47, 0x7d, 0xac, 0x48, 0x2e, 0x3a,
	0x3d, 0xcf, 0xef, 0x3a, 0xfe, 0xa1, 0xed, 0x7a, 0x7e, 0xfb, 0xdf, 0xad, 0xae, 0x83, 0x14, 0xad,
	0x42, 0xb9, 0x63, 0xb7, 0x3a, 0xc8, 0xca, 0x16, 0xb2, 0x52, 0xa5, 0xc6, 0x7e, 0x6e, 0xba, 0xbd,
	0xd3, 0x41, 0xdb, 0xf6, 0xe7, 0x99, 0xe7, 0x36, 0xc7, 0xf6, 0xce, 0x7a, 0x83, 0x23, 0xcc, 0xbf,
	0x01, 0xf5, 0xdc, 0xe6, 0xda, 0xc7, 0x9f, 0xf5, 0x15, 0xeb, 0xd7, 0x0a, 0xd4, 0x0b, 0xa0, 0x25,
	0xbd, 0xb1, 0x64, 0x5c, 0x16, 0x49, 0x32, 0xa1, 0x22, 0x95, 0x50, 0x5d, 0x6f, 0xc6, 0x80, 0x97,
	0x52, 0xaf, 0xe3, 0x50, 0x15, 0xb0, 0x39, 0xef, 0xf5, 0x42, 0x86, 0xfd, 0x3e, 0xfa, 0x8d, 0x4d,
	0xa8, 0x85, 0xf1, 0xf0, 0x5a, 0x35, 0x44, 0xce, 0x42, 0x94, 0x9c, 0x71, 0x82, 0xca, 0xa4, 0x2e,
	0x6a, 0xae, 0x23, 0x8b, 0x24, 0x41, 0x2a, 0xe6, 0x75, 0x5f, 0x96, 0x3b, 0xeb, 0x9f, 0xf7, 0x60,
	0x7c, 0xd7, 0x1b, 0x72, 0xd5, 0x9a, 0x5a, 0xb5, 0xbb, 0x64, 0x55, 0xce, 0x70, 0xdc, 0xff, 0x42,
	0x61, 0x52, 0xc7, 0xa9, 0x62, 0x78, 0xc3, 0x78, 0x0e, 0x66, 0x66, 0x4b, 0x69, 0x88, 0x1d, 0x7c,
	0xcb, 0xc4, 0xc4, 0x8f, 0x2f, 0x2f, 0x39, 0x15, 0xdc, 0xac, 0x63, 0x44, 0xc5, 0x78, 0x8d, 0x8f,
	0xc3, 0xec, 0x22, 0x73, 0x19, 0xda, 0x7b, 0xf0, 0xb6, 0x11, 0xdf, 0x5a, 0x32, 0x4e, 0x93, 0x98,
	0x53, 0x13, 0x54, 0x99, 0x9e, 0x2c, 0x2d, 0x53, 0x16, 0x72, 0x30, 0xa5, 0x82, 0xf1, 0x77, 0x58,
	0xa7, 0xdf, 0xf0, 0x21, 0x8a, 0x46, 0xd4, 0x4f, 0xb1, 0x4c, 0x66, 0x43, 0x6d, 0xb6, 0x3d, 0xd3,
	0xbc, 0xdc, 0x39, 0x40, 0x9f, 0xbc, 0x95, 0x1b, 0x7a, 0x13, 0x9b, 0xeb, 0x52, 0xaa, 0xad, 0x73,
	0x28, 0xab, 0xaa, 0x2b, 0x62, 0xb9, 0x48, 0x20, 0x4f, 0x2f, 0x1b, 0x35, 0xa8, 0x64, 0x3f, 0xe5,
	0x1d, 0x56, 0x51, 0x14, 0xdb, 0x5e, 0xf7, 0x3f, 0x36, 0xd2, 0x6a, 0xca, 0x1f, 0x28, 0xb2, 0x4d,
	0xc7, 0x96, 0xd7, 0xf3, 0x0f, 0x7f, 0x16, 0x6c, 0x58, 0xbf, 0x94, 0x30, 0x26, 0x83, 0xba, 0xc8,
	0x5b, 0x1d, 0x1a, 0xa7, 0xae, 0x3d, 0xf0, 0xfb, 0xad, 0xf3, 0x13, 0xb9, 0x4b, 0x49, 0x5a, 0x50,
	0x2c, 0xfd, 0x41, 0xcf, 0x6b, 0x79, 0xdd, 0x9e, 0x83, 0x3b, 0x3d, 0x05, 0xb3, 0xe5, 0xba, 0xa7,
	0x83, 0x96, 0x83, 0x84, 0x6b, 0xf7, 0x1c, 0x6f, 0x80, 0x79, 0xfd, 0xf6, 0x71, 0xab, 0x7b, 0x82,
	0x3c, 0xde, 0x83, 0xdd, 0x25, 0xde, 0xfe, 0xb1, 0xdd, 0xf9, 0x62, 0x23, 0xfe, 0x27, 0xf0, 0xe7,
	0x25, 0x6e, 0xd7, 0x3b, 0x3d, 0xc4, 0x13, 0xad, 0x43, 0x6d, 0xd0, 0xea, 0xba, 0xb6, 0xff, 0xd9,
	0xb6, 0xf5, 0x55, 0xcb, 0x01, 0xdd, 0x55, 0x2f, 0x42, 0x9f, 0xa0, 0x30, 0xcb, 0xe7, 0x83, 0xcb,
	0x12, 0x71, 0x12, 0x8a, 0x5c, 0x50, 0x75, 0x28, 0x45, 0x4a, 0x16, 0xb4, 0x83, 0xca, 0xeb, 0x0f,
	0x6f, 0x3f, 0xbe, 0x43, 0x7f, 0x29, 0x55, 0x3c, 0xae, 0x1c, 0x94, 0x3e, 0xca, 0xaf, 0x24, 0xd3,
	0x01, 0xf9, 0x16, 0x7f, 0x84, 0x9a, 0xfd, 0x4d, 0xd0, 0x48, 0xf6, 0x01, 0xf2, 0x66, 0x85, 0x05,
	0x2a, 0x4d, 0x4d, 0x26, 0x55, 0x8f, 0x6b, 0xd6, 0x0d, 0xc8, 0xf2, 0x1b, 0x12, 0xa1, 0x21, 0x4e,
	0x27, 0x4a, 0x7d, 0xab, 0xd6, 0x73, 0xd0, 0x3c, 0x32, 0xc2, 0x52, 0x69, 0x82, 0x8c, 0x96, 0x2d,
	0xc2, 0xa7, 0xa4, 0x28, 0xbf, 0x2e, 0x1b, 0x45, 0x34, 0x55, 0x33, 0x48, 0x48, 0x38, 0xf7, 0x23,
	0x84, 0x7f, 0x6f, 0x19, 0x8a, 0x95, 0xf5, 0x5b, 0x19, 0x56, 0xcf, 0x14, 0x13, 0xa4, 0xe6, 0x45,
	0x54, 0xdc, 0xc5, 0xe9, 0xb5, 0x2f, 0x29, 0x27, 0xd8, 0x25, 0xa3, 0x69, 0xbe, 0xe8, 0x29, 0x6c,
	0x87, 0x52, 0xbf, 0xf0, 0xd5, 0x8c, 0xfc, 0x02, 0xdf, 0xb3, 0x29, 0x01, 0x15, 0xf1, 0x9e, 0x37,
	0x53, 0xcc, 0x86, 0xea, 0x51, 0x14, 0xf8, 0xef, 0xfd, 0xb2, 0x83, 0xf1, 0x7b, 0xc8, 0xcd, 0xa6,
	0x6a, 0x59, 0x13, 0xb4, 0x6c, 0x64, 0x90, 0xed, 0x56, 0x2f, 0x4c, 0x27, 0xc6, 0x2b, 0xa8, 0x17,
	0x35, 0xb6, 0xbc, 0x28, 0x9f, 0x45, 0x91, 0x79, 0x09, 0xcd, 0x3b, 0x22, 0x86, 0x57, 0x72, 0xa0,
	0x52, 0xaf, 0x8c, 0xb9, 0xa1, 0x82, 0x9b, 0xd3, 0xe0, 0xfc, 0xad, 0x6d, 0xc3, 0x46, 0x3e, 0x15,
	0xa8, 0xc7, 0x55, 0xbe, 0x0c, 0x15, 0xd5, 0x51, 0xb3, 0x0e, 0x3c, 0x5b, 0x98, 0x07, 0x30, 0x4a,
	0x0a, 0xec, 0x41, 0xfd, 0xd4, 0x99, 0x3d, 0xfd, 0xc6, 0xbf, 0x66, 0x23, 0xa1, 0x4c, 0x92, 0xcc,
	0x08, 0x92, 0x0f, 0x48, 0x66, 0x61, 0xcf, 0x45, 0x02, 0x19, 0x73, 0x29, 0x5c, 0xcb, 0x89, 0x61,
	0xbc, 0x80, 0x1a, 0x9d, 0x12, 0x03, 0xbb, 0x5b, 0x82, 0xde, 0x9c, 0x37, 0xe8, 0x94, 0x31, 0x38,
	0xff, 0x05, 0x34, 0x3b, 0x99, 0x8c, 0xab, 0xab, 0x79, 0x6a, 0x17, 0x36, 0xb1, 0x70, 0x3e, 0x4e,
	0xc8, 0xf3, 0x59, 0x41, 0xf5, 0x6f, 0x19, 0x5d, 0x65, 0x64, 0x0b, 0x37, 0xf5, 0xc5, 0xa2, 0x4a,
	0x22, 0x7d, 0x80, 0xad, 0xa2, 0xd8, 0x71, 0x45, 0x17, 0x6e, 0x6e, 0xfe, 0xa1, 0xda, 0x65, 0x84,
	0xb2, 0x3e, 0x41, 0x73, 0xb1, 0x28, 0x52, 0xfa, 0x0b, 0x65, 0x79, 0x68, 0x40, 0xb2, 0x06, 0xd0,
	0x58, 0x50, 0x1b, 0xc9, 0x4e, 0x9c, 0x3e, 0xfc, 0xe2, 0x84, 0x80, 0xb6, 0x4b, 0x86, 0x2f, 0x6e,
	0x66, 0x53, 0xe3, 0x8e, 0x24, 0xa6, 0xb2, 0x0d, 0xc7, 0x69, 0x8a, 0x35, 0x9f, 0x64, 0x13, 0xb5,
	0x6c, 0x8c, 0xda, 0xe1, 0x1e, 0x6c, 0xc5, 0xe9, 0x68, 0xff, 0x82, 0x09, 0x99, 0xea, 0xbf, 0x39,
	0xf2, 0xc3, 0xd5, 0xbe, 0xfc, 0xcb, 0xc0, 0x7f, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x3c, 0xf3, 0x5a,
	0x39, 0x42, 0x0c, 0x00, 0x00,
}
